---
title: "T1-Y2"
output: html_document
date: "2025-06-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
Sys.setenv(JAVA_HOME = "C:/Program Files/Eclipse Adoptium/jdk-21.0.7.6-hotspot")

install.packages("rJava")
library(rJava)

install.packages("bartMachine")
options(java.parameters = "-Xmx4g")  # 메모리 충분히
library(bartMachine)
set_bart_machine_num_cores(4)
```

```{r}
library(dplyr)
library(tidyr)
library(readr)
library(skimr)

library(MatchIt)
library(cobalt)
library(glmnet)
library(forcats)
library(cfcausal)
library(grf)

library(ggplot2)
```

```{r}
data <- read_csv("C:/Users/1004c/Desktop/통계청 논문 공모전/Data/df_processed.csv")

skim(data)
names(data)
```

# Assumptions
- 중소기업 청년취업인턴제

(1) df_T1: "청년취업인턴제_들어본_경험"이 있는 사람들만 뽑기
```{r}
# Y - (임금) 취업 여부 => 이것만 활용
selected_cols_T1 <- grep("^(X1_|X2_|X3_|Y_첫_직장에_대한_전반적인_만족도|T1_)", names(data), value = TRUE)

# 중소기업 청년 취업 인턴제 들어본 경험이 있는 경우만 filtering
df_T1 <- data %>%
  select(all_of(selected_cols_T1)) %>%
  filter(T1_중소기업_청년취업인턴제_들어본_경험 == 1)
```


(2) Y가 0인 값 제외
```{r}
df_T1 <- df_T1 %>%
  filter(Y_첫_직장에_대한_전반적인_만족도 != 0)

df_T1$Y_첫_직장에_대한_전반적인_만족도 <- as.ordered(df_T1$Y_첫_직장에_대한_전반적인_만족도)
```


(2) NA value 처리
- 연령대: Missing 유지(Categorical)
- 부모소득구간: Missing 유지(Categorical)
- 부모학력: NA 지우기
```{r}
df_T1 <- df_T1 %>%
  filter(!is.na(X1_부모학력)) %>%
  mutate(
    X1_연령대 = fct_na_value_to_level(as.factor(X1_연령대), level = "Missing"),
    X1_부모소득구간 = fct_na_value_to_level(as.factor(X1_부모소득구간), level = "Missing"),
    X2_전공그룹 = as.factor(X2_전공그룹)
  )
```

```{r}
# Missing이라는 범주가 생겼는지 확인
levels(df_T1$X1_연령대)
levels(df_T1$X1_부모소득구간)

# NA 개수 여전히 있는지 확인 (X1_부모학력은 그대로 두기로 함)
sum(is.na(df_T1$X1_부모학력))
```
## 1. Ignorability
- 처치와 결과가 공변량 X에 조건부로 독립임: 처치군과 통제군의 공변량 분포가 유사해야 함

```{r}
names(df_T1)
```

(1) raw data 기준
```{r}
# 1. covariates만 선택: Y_, T1_ 으로 시작하는 변수 제외
covariates <- names(df_T1)
covariates <- covariates[!grepl("^Y_|^T1_", covariates)]

treat_col <- "T1_중소기업_청년취업인턴제_참여경험"

# 2. Formula 생성
fml <- as.formula(paste(treat_col, "~", paste(covariates, collapse = " + ")))

# 3. 공변량 균형 상태 확인 (처치만 적용된 원자료 기준)
bal.tab(fml, 
        data = df_T1,
        un = TRUE,
        m.threshold = 0.1)

# 4. 시각화 (처치 전 SMD 기준 love plot)
love.plot(fml, 
          data = df_T1, 
          threshold = 0.1)
```

(2) weighted 포함 ignorability check
```{r}
# 1. covariates만 선택: Y_, T1_ 으로 시작하는 변수 제외
covariates <- names(df_T1)
covariates <- covariates[!grepl("^Y_|^T1_", covariates)]

treat_col <- "T1_중소기업_청년취업인턴제_참여경험"

# 2. Formula 생성
fml_weighted <- as.formula(paste(treat_col, "~", paste(covariates, collapse = " + ")))

# 3. propensity score 추정
ps_model <- glm(fml_weighted, data = df_T1, family = binomial)
ps <- predict(ps_model, type = "response")

# 4. ATE 기반 inverse propensity weights 계산
df_T1$weights <- ifelse(df_T1[[treat_col]] == 1,
                        1 / ps,
                        1 / (1 - ps))

# 5. 공변량 균형 평가
bal.tab(fml_weighted,
        data = df_T1,
        weights = df_T1$weights,
        method = "weighting",
        un = TRUE,
        m.threshold = 0.1)

# 6. love plot 출력
love.plot(fml_weighted,
          data = df_T1,
          weights = df_T1$weights,
          method = "weighting",
          threshold = 0.1)
```


## 2. Overlap
- Propensity score이 0 또는 1에 치우치지 않고, 모든 관측치에서 0 < e(x) < 1의 분포를 갖는다는 가정
- 처치군/통제군의 PS 분포가 겹치는지 확인

```{r}
# 1. covariates만 선택: Y_, T1_, weights 으로 시작하는 변수 제외
covariates <- names(df_T1)
covariates <- covariates[!grepl("^Y_|^T1_|^weights", covariates)]

treat_col <- "T1_중소기업_청년취업인턴제_참여경험"

# 2. Formula 생성
fml_weighted <- as.formula(paste(treat_col, "~", paste(covariates, collapse = " + ")))

# 3. propensity score 추정
ps_model <- glm(fml_weighted, data = df_T1, family = binomial)
ps <- predict(ps_model, type = "response")

# 4. Truncate
ps <- pmin(pmax(ps, 0.1), 0.9)

# 5. ps, treat_label 생성 (plot 용)
df_T1$ps <- ps
df_T1$treat_label <- ifelse(df_T1[[treat_col]] == 1, "Treated", "Control")

# 6. Overlap 시각화
ggplot(df_T1, aes(x = ps, fill = treat_label)) +
  geom_density(alpha = 0.4) +
  labs(title = "Propensity Score Overlap", x = "Propensity Score", fill = "Group") +
  theme_minimal()
```

(2) 최종 분석에 사용할 df_T1_final 생성
```{r}
quantile(df_T1$ps, probs = c(0, 0.01, 0.05, 0.1, 0.9, 0.95, 0.99, 1))
df_cf <- df_T1[df_T1$ps >= 0.01 & df_T1$ps <= 0.99, ]

# 1. 안 쓰는 변수 제거: weights, ps, treat_label, T1_중소기업_청년취업인턴제_들어본_경험
drop_vars <- c("weights", "ps", "treat_label", "T1_중소기업_청년취업인턴제_들어본_경험")
df_cf <- df_cf[, !(names(df_cf) %in% drop_vars)]
```

```{r}
names(df_cf)
skim(df_cf)
str(df_cf)
```

(3) 최종 df(df_cf_T1) 저장
```{r}
file_path = "C:/Users/1004c/Desktop/통계청 논문 공모전/Data/T1_Y2/df_cf_T1.csv"

write_excel_csv(df_cf, file_path)
```

# ITE CQR

```{r}
df_cf <- read_csv("C:/Users/1004c/Desktop/통계청 논문 공모전/Data/T1_Y2/df_cf_T1.csv")
```

1. X/Xtest 동시에 처리
```{r}
prepare_X_Xtest <- function(X, Xtest) {
  X <- as.data.frame(X)
  Xtest <- as.data.frame(Xtest)

  # 문자형 → factor
  convert <- function(df) {
    df[] <- lapply(df, function(col) {
      if (is.character(col)) factor(col) else col
    })
    return(df)
  }
  X <- convert(X)
  Xtest <- convert(Xtest)

  # factor level 맞추기 (X 기준으로 Xtest 맞추기)
  for (col in intersect(names(X), names(Xtest))) {
    if (is.factor(X[[col]])) {
      common_levels <- union(levels(X[[col]]), levels(Xtest[[col]]))
      X[[col]] <- factor(X[[col]], levels = common_levels)
      Xtest[[col]] <- factor(Xtest[[col]], levels = common_levels)
    }
  }

  # 상수/빈 변수 제거
  keep_cols <- sapply(X, function(col) {
    !(is.factor(col) && length(levels(col)) == 0) && length(unique(col)) > 1
  })
  X <- X[, keep_cols]
  Xtest <- Xtest[, names(X), drop = FALSE]

  # 정규화 (수치형만)
  is_num <- sapply(X, is.numeric)
  if (any(is_num)) {
    means <- sapply(X[is_num], mean)
    sds <- sapply(X[is_num], sd)
    X[is_num] <- scale(X[is_num], center = means, scale = sds)
    Xtest[is_num] <- scale(Xtest[is_num], center = means, scale = sds)
  }

  return(list(X = X, Xtest = Xtest))
}
```


1. myOrdinal 정의
```{r}
myOrdinal <- function(Y, X, Xtest){
  library(MASS)

  X <- as.data.frame(X)
  Xtest <- as.data.frame(Xtest)

  Y <- as.ordered(Y)
  data <- data.frame(Y = Y, X)

  fit <- polr(Y ~ ., data = data, method = "logistic")
  probs <- predict(fit, newdata = Xtest, type = "prob")

  expected_scores <- probs %*% as.numeric(colnames(probs))  # 1~5 클래스
  return(as.numeric(expected_scores))  # <- conformalIte에서 요구하는 형식
}
```

```{r}
myOrdinal <- function(Y, X, Xtest) {
  library(ordinal)

  # 1. 데이터프레임 변환
  X <- as.data.frame(X)
  Xtest <- as.data.frame(Xtest)

  # 2. 문자형 변수 → factor 변환 (gbm 등과 호환을 위해 안전하게)
  X[] <- lapply(X, function(col) if (is.character(col)) factor(col) else col)
  Xtest[] <- lapply(Xtest, function(col) if (is.character(col)) factor(col) else col)

  # 3. Y를 순서형 factor로 정의
  Y <- factor(Y, levels = sort(unique(Y)), ordered = TRUE)

  # 4. 모델 적합
  data <- data.frame(Y = Y, X)
  fit <- clm(Y ~ ., data = data, link = "logit")

  # 5. 예측: 클래스별 확률 × 점수 기대값
  probs <- predict(fit, newdata = Xtest, type = "prob")$fit
  expected_scores <- probs %*% as.numeric(levels(Y))

  return(as.numeric(expected_scores))  # conformalIte가 기대하는 형식
}

```


```{r}
myOrdinal <- function(Y, X, Xtest){
  library(MASS)

  X <- as.data.frame(X)
  Xtest <- as.data.frame(Xtest)

  Y <- as.ordered(Y)
  data <- data.frame(Y = Y, X)

  tryCatch({
    fit <- polr(Y ~ ., data = data, method = "logistic", Hess = TRUE)
    probs <- predict(fit, newdata = Xtest, type = "prob")
    expected_scores <- probs %*% as.numeric(colnames(probs))
    return(as.numeric(expected_scores))
  }, error = function(e) {
    message("⚠️ polr 실패, multinom으로 대체")
    library(nnet)
    fit <- multinom(Y ~ ., data = data)
    probs <- predict(fit, newdata = Xtest, type = "probs")
    expected_scores <- probs %*% as.numeric(levels(Y))
    return(as.numeric(expected_scores))
  })
}
```

```{r}
myOrdinal <- function(Y, X, Xtest) {
  library(ordinal)
  
  # 1. prepare_X_Xtest로 바꿔서 
  processed <- prepare_X_Xtest(X, Xtest)
  X <- processed$X
  Xtest <- processed$Xtest

  # 2. 문자형 → factor로 변환
  X[] <- lapply(X, function(col) {
    if (is.character(col)) factor(col) else col
  })
  Xtest[] <- lapply(Xtest, function(col) {
    if (is.character(col)) factor(col) else col
  })

  # 3. 순서형 Y 정의 (예: 1~5 만족도)
  Y <- factor(as.integer(Y), levels = 1:5, ordered = TRUE)

  # 4. 문제 있는 변수 제거 (level 없는 factor, 상수 등)
  X <- X[, sapply(X, function(col) {
    !(is.factor(col) && length(levels(col)) == 0) && length(unique(col)) > 1
  })]
  Xtest <- Xtest[, colnames(X), drop = FALSE]

  # 5. 수치형 변수 정규화 (optional)
  is_num <- sapply(X, is.numeric)
  X[is_num] <- scale(X[is_num])
  Xtest[is_num] <- scale(Xtest[is_num])

  # 6. 모델 적합
  data <- data.frame(Y = Y, X)
  fit <- tryCatch({
    clm(Y ~ ., data = data, link = "logit")
  }, error = function(e) {
    stop("❌ clm 모델 적합 실패: ", e$message)
  })

  # 7. 예측
  probs <- predict(fit, newdata = Xtest, type = "prob")$fit
  expected_scores <- probs %*% as.numeric(levels(Y))
  return(as.numeric(expected_scores))
}
```


2. myPSfun / myBoostingPS 정의
- PS는 nominal만 받을 수 있는데 현재 ordinal data로 Y가 정해져있음: 따라서 처음에 T를 factor로 변환하는 부분이 포함된 psfun을 정의
- psfun은 ordinal을 다룰 수 없음
```{r}
myPSfun <- function(Y, X, Xtest) {
  Y <- factor(Y)              # 처치 변수 (0/1)
  
  processed <- prepare_X_Xtest(X, Xtest)
  X <- processed$X
  Xtest <- processed$Xtest

  model <- glm(Y ~ ., data = data.frame(Y = Y, X), family = binomial)
  preds <- predict(model, newdata = Xtest, type = "response")
  return(preds)  # 처치 확률 (P(T=1 | Xtest))
}
```

```{r}
myBoostingPS <- function(Y, X, Xtest) {
  library(gbm)
  
  # Y는 여기서 처치 변수 (0/1)
  Y <- as.numeric(as.character(Y))  # factor → numeric (0/1)
  
  processed <- prepare_X_Xtest(X, Xtest)
  X <- processed$X
  Xtest <- processed$Xtest


  model <- gbm.fit(
    x = X, y = Y,
    distribution = "bernoulli",
    n.trees = 100,
    interaction.depth = 3,
    shrinkage = 0.05,
    verbose = FALSE
  )
  
  preds <- predict(model, newdata = Xtest, n.trees = 100, type = "response")
  return(preds)  # 확률값 (P(T=1 | Xtest))
}
```


```{r}
# T: 처치 변수 (0/1), Y: 결과 변수, X: 공변량
T <- df_cf$T1_중소기업_청년취업인턴제_참여경험
Y <- df_cf$Y_첫_직장에_대한_전반적인_만족도
# Y <- as.factor(Y)
X <- df_cf[, setdiff(names(df_cf), c("T1_중소기업_청년취업인턴제_참여경험", "Y_임금근로자_첫_일자리"))]

# 수치형 행렬로 변환 (factor 포함)
X_mat <- model.matrix(~ . - 1, data = X)

# conformal ITE 추정 함수 정의
CIfun <- conformalIte(
  X = X_mat, 
  Y = Y, 
  T = T, 
  alpha = 0.1,
  algo = "nest",
  exact = TRUE,
  type = "mean",       # 평균 ITE 기반
  outfun = myOrdinal,     # 베이지안 회귀 트리
  psfun = myPSfun,  # 처치 확률 추정 (GBM 기반)
  citype = "mean",     # 신뢰구간 방법도 mean 기반
  useCV = FALSE         # CV+ 방식 사용
)

# X 활용한 예측
result <- CIfun(X_mat)

result

```
```{r}
debugonce(CIfun)
```

```{r}
# 1. Y가 factor인지 확인
str(Y)

# 2. level 1개뿐이면 에러 발생
table(Y)

# 3. ordered면 제거
Y <- as.factor(Y)

# 4. level 정리
Y <- droplevels(Y)

```


```{r}
file_path = "C:/Users/1004c/Desktop/통계청 논문 공모전/Data/T1_Y1/T1_mean_myOrdinal_cla.csv"

result_df <- as.data.frame(result)
write_excel_csv(result_df, file_path)
```



## 1. 신뢰구간 Evaluation

```{r}
result_df <- as.data.frame(result)
```

```{r}
# Y: 실제 관측값 (예: Y <- df_cf$Y_임금근로자_첫_일자리)
# result_df: 신뢰구간 결과 (columns: lower, upper)

# 1. Empirical Coverage
result_df$Y <- Y  # 실제값 붙이기
result_df$covered <- with(result_df, Y >= lower & Y <= upper)
empirical_coverage <- mean(result_df$covered)

# 2. Interval Length
result_df$interval_length <- with(result_df, upper - lower)
mean_interval_length <- mean(result_df$interval_length)

# 3. Lower bound > 0 비율
result_df$lower_positive <- result_df$lower > 0
proportion_lower_positive <- mean(result_df$lower_positive)

# 결과 출력
cat("Empirical Coverage:", round(empirical_coverage, 3), "\n")
cat("Mean Interval Length:", round(mean_interval_length, 3), "\n")
cat("Proportion with Lower Bound > 0:", round(proportion_lower_positive, 3), "\n")
```
```{r}
library(ggplot2)

# Histogram of lower bounds
ggplot(result_df, aes(x = lower)) +
  geom_histogram(bins = 50, fill = "skyblue", color = "black") +
  labs(title = "Distribution of Lower Bounds", x = "Lower Bound", y = "Count")

# Boxplot of interval lengths
ggplot(result_df, aes(y = interval_length)) +
  geom_boxplot(fill = "lightgreen") +
  labs(title = "Interval Length Distribution", y = "Interval Length")

```