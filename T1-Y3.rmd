---
title: "T1-Y3"
output: html_document
date: "2025-06-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
Sys.setenv(JAVA_HOME = "C:/Program Files/Eclipse Adoptium/jdk-21.0.7.6-hotspot")

install.packages("rJava")
library(rJava)

install.packages("bartMachine")
options(java.parameters = "-Xmx4g")  # 메모리 충분히
library(bartMachine)
set_bart_machine_num_cores(4)
```

```{r}
library(dplyr)
library(tidyr)
library(readr)
library(skimr)

library(MatchIt)
library(cobalt)
library(glmnet)
library(forcats)
library(cfcausal)
library(grf)

library(ggplot2)
```

```{r}
data <- read_csv("C:/Users/1004c/Desktop/통계청 논문 공모전/Data/df_processed.csv")

skim(data)
names(data)
```


# Assumptions
- 중소기업 청년취업인턴제

(1) df_T1: "청년취업인턴제_들어본_경험"이 있는 사람들만 뽑기
```{r}
# Y - (임금) 취업 여부 => 이것만 활용
selected_cols_T1 <- grep("^(X1_|X2_|X3_|Y_전년도_근로_사업_소득액|Y_log_소득|T1_)", names(data), value = TRUE)

# 중소기업 청년 취업 인턴제 들어본 경험이 있는 경우만 filtering
df_T1 <- data %>%
  select(all_of(selected_cols_T1)) %>%
  filter(T1_중소기업_청년취업인턴제_들어본_경험 == 1)
```


(2) Y가 0인 값 제외
```{r}
df_T1 <- df_T1 %>%
  mutate(Y_전년도_근로_사업_소득액 = ifelse(Y_전년도_근로_사업_소득액 == -1, NA, Y_전년도_근로_사업_소득액)) %>%
  filter(Y_전년도_근로_사업_소득액 > 0)
```


(2) NA value 처리
- 연령대: Missing 유지(Categorical)
- 부모소득구간: Missing 유지(Categorical)
- 부모학력: NA 지우기
```{r}
df_T1 <- df_T1 %>%
  filter(!is.na(X1_부모학력)) %>%
  mutate(
    X1_연령대 = fct_na_value_to_level(as.factor(X1_연령대), level = "Missing"),
    X1_부모소득구간 = fct_na_value_to_level(as.factor(X1_부모소득구간), level = "Missing"),
    X2_전공그룹 = as.factor(X2_전공그룹)
  )
```

```{r}
# Missing이라는 범주가 생겼는지 확인
levels(df_T1$X1_연령대)
levels(df_T1$X1_부모소득구간)

# NA 개수 여전히 있는지 확인 (X1_부모학력은 그대로 두기로 함)
sum(is.na(df_T1$X1_부모학력))
```
## 1. Ignorability
- 처치와 결과가 공변량 X에 조건부로 독립임: 처치군과 통제군의 공변량 분포가 유사해야 함

```{r}
names(df_T1)
skim(df_T1)
```

(1) raw data 기준
```{r}
# 1. covariates만 선택: Y_, T1_ 으로 시작하는 변수 제외
covariates <- names(df_T1)
covariates <- covariates[!grepl("^Y_|^T1_", covariates)]

treat_col <- "T1_중소기업_청년취업인턴제_참여경험"

# 2. Formula 생성
fml <- as.formula(paste(treat_col, "~", paste(covariates, collapse = " + ")))

# 3. 공변량 균형 상태 확인 (처치만 적용된 원자료 기준)
bal.tab(fml, 
        data = df_T1,
        un = TRUE,
        m.threshold = 0.1)

# 4. 시각화 (처치 전 SMD 기준 love plot)
love.plot(fml, 
          data = df_T1, 
          threshold = 0.1)
```

(2) weighted 포함 ignorability check
```{r}
# 1. covariates만 선택: Y_, T1_ 으로 시작하는 변수 제외
covariates <- names(df_T1)
covariates <- covariates[!grepl("^Y_|^T1_", covariates)]

treat_col <- "T1_중소기업_청년취업인턴제_참여경험"

# 2. Formula 생성
fml_weighted <- as.formula(paste(treat_col, "~", paste(covariates, collapse = " + ")))

# 3. propensity score 추정
ps_model <- glm(fml_weighted, data = df_T1, family = binomial)
ps <- predict(ps_model, type = "response")

# 4. ATE 기반 inverse propensity weights 계산
df_T1$weights <- ifelse(df_T1[[treat_col]] == 1,
                        1 / ps,
                        1 / (1 - ps))

# 5. 공변량 균형 평가
bal.tab(fml_weighted,
        data = df_T1,
        weights = df_T1$weights,
        method = "weighting",
        un = TRUE,
        m.threshold = 0.1)

# 6. love plot 출력
love.plot(fml_weighted,
          data = df_T1,
          weights = df_T1$weights,
          method = "weighting",
          threshold = 0.1)
```


## 2. Overlap
- Propensity score이 0 또는 1에 치우치지 않고, 모든 관측치에서 0 < e(x) < 1의 분포를 갖는다는 가정
- 처치군/통제군의 PS 분포가 겹치는지 확인

```{r}
# 1. covariates만 선택: Y_, T1_, weights 으로 시작하는 변수 제외
covariates <- names(df_T1)
covariates <- covariates[!grepl("^Y_|^T1_|^weights", covariates)]

treat_col <- "T1_중소기업_청년취업인턴제_참여경험"

# 2. Formula 생성
fml_weighted <- as.formula(paste(treat_col, "~", paste(covariates, collapse = " + ")))

# 3. propensity score 추정
ps_model <- glm(fml_weighted, data = df_T1, family = binomial)
ps <- predict(ps_model, type = "response")

# 4. Truncate
ps <- pmin(pmax(ps, 0.1), 0.9)

# 5. ps, treat_label 생성 (plot 용)
df_T1$ps <- ps
df_T1$treat_label <- ifelse(df_T1[[treat_col]] == 1, "Treated", "Control")

# 6. Overlap 시각화
ggplot(df_T1, aes(x = ps, fill = treat_label)) +
  geom_density(alpha = 0.4) +
  labs(title = "Propensity Score Overlap", x = "Propensity Score", fill = "Group") +
  theme_minimal()
```

(2) 최종 분석에 사용할 df_T1_final 생성
```{r}
quantile(df_T1$ps, probs = c(0, 0.01, 0.05, 0.1, 0.9, 0.95, 0.99, 1))
df_cf <- df_T1[df_T1$ps >= 0.01 & df_T1$ps <= 0.99, ]

# 1. 안 쓰는 변수 제거: weights, ps, treat_label, T1_중소기업_청년취업인턴제_들어본_경험
drop_vars <- c("weights", "ps", "treat_label", "T1_중소기업_청년취업인턴제_들어본_경험")
df_cf <- df_cf[, !(names(df_cf) %in% drop_vars)]
```

```{r}
names(df_cf)
skim(df_cf)
str(df_cf)
```

(3) 최종 df(df_cf_T1) 저장
```{r}
file_path = "C:/Users/1004c/Desktop/통계청 논문 공모전/Data/T1_Y3/df_cf_T1.csv"

write_excel_csv(df_cf, file_path)
```


# ITE - CQR
```{r}
df_cf <- read_csv("C:/Users/1004c/Desktop/통계청 논문 공모전/Data/T1_Y3/df_cf_T1.csv")
```
```{r}
names(df_cf)
```
```{r}
summary(df_cf$Y_전년도_근로_사업_소득액)
hist(df_cf$Y_전년도_근로_사업_소득액, breaks = 50)
```



```{r}
# T: 처치 변수 (0/1), Y: 결과 변수, X: 공변량
T <- df_cf$T1_중소기업_청년취업인턴제_참여경험
Y <- df_cf$Y_전년도_근로_사업_소득액
# Y <- as.factor(Y)
X <- df_cf[, setdiff(names(df_cf), c("T1_중소기업_청년취업인턴제_참여경험", "Y_임금근로자_첫_일자리"))]

# 수치형 행렬로 변환 (factor 포함)
X_mat <- model.matrix(~ . - 1, data = X)

# conformal ITE 추정 함수 정의
CIfun <- conformalIte(
  X = X_mat, 
  Y = Y, 
  T = T, 
  alpha = 0.1,
  algo = "nest",
  exact = TRUE,
  type = "CQR",       # 평균 ITE 기반
  outfun = "quantRF",     # 베이지안 회귀 트리
  psfun = "Boosting",  # 처치 확률 추정 (GBM 기반)
  citype = "mean",     # 신뢰구간 방법도 mean 기반
  quantiles = c(0.05, 0.95),
  useCV = FALSE         # CV+ 방식 사용
)

# X 활용한 예측
result <- CIfun(X_mat)

result
```

```{r}
file_path = "C:/Users/1004c/Desktop/통계청 논문 공모전/Data/T1_Y1/T1_mean_myOrdinal_cla.csv"

result_df <- as.data.frame(result)
write_excel_csv(result_df, file_path)
```


## 1. 신뢰구간 Evaluation

```{r}
result_df <- as.data.frame(result)
```

```{r}
# Y: 실제 관측값 (예: Y <- df_cf$Y_임금근로자_첫_일자리)
# result_df: 신뢰구간 결과 (columns: lower, upper)

# 1. Empirical Coverage
result_df$Y <- Y  # 실제값 붙이기
result_df$covered <- with(result_df, Y >= lower & Y <= upper)
empirical_coverage <- mean(result_df$covered)

# 2. Interval Length
result_df$interval_length <- with(result_df, upper - lower)
mean_interval_length <- mean(result_df$interval_length)

# 3. Lower bound > 0 비율
result_df$lower_positive <- result_df$lower > 0
proportion_lower_positive <- mean(result_df$lower_positive)

# 결과 출력
cat("Empirical Coverage:", round(empirical_coverage, 3), "\n")
cat("Mean Interval Length:", round(mean_interval_length, 3), "\n")
cat("Proportion with Lower Bound > 0:", round(proportion_lower_positive, 3), "\n")
```
```{r}
library(ggplot2)

# Histogram of lower bounds
ggplot(result_df, aes(x = lower)) +
  geom_histogram(bins = 50, fill = "skyblue", color = "black") +
  labs(title = "Distribution of Lower Bounds", x = "Lower Bound", y = "Count")

# Boxplot of interval lengths
ggplot(result_df, aes(y = interval_length)) +
  geom_boxplot(fill = "lightgreen") +
  labs(title = "Interval Length Distribution", y = "Interval Length")

```
